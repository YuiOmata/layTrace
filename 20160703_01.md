# Processingã§ãƒ¬ã‚¤ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ï¼

ç¬¬ä¸€ç« : ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆãƒ»ãã®ï¼‘  

å°æ¸• è±Š ( @FMS_Cat )  
Light Transport Entertainment Inc.  

# æœ€çµ‚ç›®æ¨™

æœ€çµ‚çš„ã«ã¯ã€æˆ‘ã€…ã¯çµµã‚’æããŸã„  
â†’ **çµµã‚’æ§‹æˆã™ã‚‹å„ãƒ”ã‚¯ã‚»ãƒ«ã«å¯¾å¿œã™ã‚‹è‰²ã‚’çŸ¥ã‚ŠãŸã„**  

```Processing
void setup() {
  size(256, 256);

  for (int iy = 0; iy < height; iy ++) {
    for (int ix = 0; ix < width; ix ++) {
      stroke(calcPixelColor(ix, iy));
      point(ix, iy);
    }
  }
}
```

# è©¦ã—ã«

ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æã„ã¦ã¿ã‚‹  

```Processing
color calcPixelColor(int x, int y) {
  int red = int(x * 1.0 / width * 256.0);
  int green = int(y * 1.0 / height * 256.0);
  return color(
    red,
    green,
    0
  );
}
```

![](https://i.imgur.com/fd4gPDH.png)

# ä»Šå›ã®ç›®æ¨™

çƒä½“ã‚·ãƒ«ã‚¨ãƒƒãƒˆã®æç”»  

![](https://i.imgur.com/OGeGweq.png)

# ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆï¼Ÿ

ã‚ã‚‹ç‚¹ã‹ã‚‰ã‚ã‚‹æ–¹å‘ã«åŠç›´ç·šã‚’é£›ã°ã—ã€åŠç›´ç·šãŒãƒ¢ãƒã¨äº¤å·®ã™ã‚‹ã‹ã‚’èª¿ã¹ã‚‹  

![](https://i.imgur.com/HDe6ZUJ.png)  

# ãƒ¬ã‚¤

åŠç›´ç·šã‚’ **ãƒ¬ã‚¤** ã¨å‘¼ã¶  
ãƒ¬ã‚¤ã¯ **å§‹ç‚¹** ã¨ **æ–¹å‘** ã®æƒ…å ±ã‚’æŒã¤  

ğŸ¤” < ã§ã‚‚ã©ã‚“ãªæƒ…å ±ã â€¦ï¼Ÿ  

# ãƒ™ã‚¯ãƒˆãƒ«

**ãƒ™ã‚¯ãƒˆãƒ«** : å¤§ãã•ã¨å‘ãã‚’æŒã£ãŸé‡  
çŸ¢å°ã®ãƒ¡ã‚¿ãƒ•ã‚¡ã§è¡¨ã‚ã•ã‚Œã‚‹ã“ã¨ãŒå¤šã„  

![](https://i.imgur.com/KJG0p7l.png)  

3æ¬¡å…ƒç©ºé–“ã§ã¯ã€x, y, zã®3æˆåˆ†ã‚’æŒã¤  

# Vec

`Vec` ï¼ˆãƒ™ã‚¯ãƒˆãƒ«ï¼‰ã‚¯ãƒ©ã‚¹ã‚’ã‚ã‚‰ã‹ã˜ã‚ç”¨æ„ã—ã¦ã‚ã‚Šã¾ã™  

## ãƒ¡ãƒ³ãƒå¤‰æ•°  

- `float x`  
- `float y`  
- `float z`  

## ãƒ¡ãƒ³ãƒãƒ¡ã‚½ãƒƒãƒ‰  

- `String toString()` : `"Vec(1.0, 2.0, 3.0)"` ã®ã‚ˆã†ã«æ–‡å­—åˆ—ã‚’å‡ºåŠ›  
- `Vec add(Vec)` : ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®åŠ ç®—  
- `Vec sub(Vec)` : ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®æ¸›ç®—  
- `Vec scale(float)` : ãƒ™ã‚¯ãƒˆãƒ«ã®å®šæ•°å€  
- `Vec neg()` : é€†å‘ãã®ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¿”ã™  
- `float len()` : ãƒ™ã‚¯ãƒˆãƒ«ã®é•·ã•ã‚’è¿”ã™  
- `Vec normalize()` : æ­£è¦åŒ–ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¿”ã™ï¼ˆé•·ã•ãŒ1ã«ãªã‚‹ï¼‰  
- `float dot(Vec)` : å†…ç©  
- `Vec cross(Vec)` : å¤–ç©

â“ < ã¨ã“ã‚ã§ã€ã‚¯ãƒ©ã‚¹ã£ã¦ã¿ã‚“ãªã‚ã‹ã‚‹ï¼Ÿ

# Vecã§ã‚ãã¼ã†

```
void setup() {
  Vec vec = new Vec(1.0, 2.0, 3.0); // ãƒ™ã‚¯ãƒˆãƒ«ã‚’ä½œã‚‹
  println(vec); // ãƒ™ã‚¯ãƒˆãƒ«ã‚’Consoleã«å‡ºåŠ›

  vec = vec.add(new Vec(5.0, 1.0, 3.0)); // ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®è¶³ã—ç®—
  println(vec); // è¶³ã—ãŸå¾Œã®ãƒ™ã‚¯ãƒˆãƒ«ã‚’Consoleã«å‡ºåŠ›

  println(vec.len()); // ãƒ™ã‚¯ãƒˆãƒ«ã®é•·ã•ã‚’Consoleã«å‡ºåŠ›
}
```

# Ray

`Vec` ãŒã§ãã‚Œã° `Ray` ï¼ˆãƒ¬ã‚¤ï¼‰ã‚‚ä½œã‚Œã‚‹ï¼  
Remember: ãƒ¬ã‚¤ã¯åŠç›´ç·šã€ **å§‹ç‚¹** ã¨ **æ–¹å‘** ã®æƒ…å ±ã‚’æŒã¤  

## ãƒ¡ãƒ³ãƒå¤‰æ•°

- `Vec origin` : å§‹ç‚¹  
- `Vec dir` : æ–¹å‘  

# æœ€åˆã®ç›®æ¨™

**ãƒ¬ã‚¤ã‚’é£›ã°ã—ãŸå…ˆã«ç‰©ãŒã‚ã‚‹ã‹èª¿ã¹ãŸã„**  

```Processing
boolean isIntersect(Ray ray) {
  ...
}
```

# ã‚·ãƒ¼ãƒ³

ãƒ™ã‚¯ãƒˆãƒ«ã¨ãƒ¬ã‚¤ã¯ã§ããŸâ€¦  
ã§ã‚‚ä½•ã‚‚ãªã„ç©ºé–“ã§ãƒ¬ã‚¤ã‚’é£›ã°ã—ã¦ã‚‚ã€ä½•ã‚‚èµ·ã“ã‚‰ãªã„â€¦ï¼ï¼ï¼  

â†’ **ãƒ¢ãƒ** ã¨ **ç©ºé–“** ã‚’å®šç¾©ã—ã‚ˆã†  

# Intersectable

**ãƒ¢ãƒ** ã¯ `Intersectable` ã¨ã—ã¦å®šç¾©ã—ã¾ã™  

```Processing
interface Intersectable {
  boolean isIntersect(Ray ray);
}
```

ã¤ã¾ã‚Š:  
ãƒ¢ãƒãŒãƒ¢ãƒã§ã‚ã‚‹ãŸã‚ã«ã€  
`Ray` ã‚’æŠ•ã’ã‚‹ã¨ `boolean` ã‚’è¿”ã™ `isIntersect`  
ã¨ã„ã†ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ã­  

# Sphere

è©¦ã—ã« **çƒ** ã‚’ `Intersectable` ã¨ã—ã¦å®Ÿè£…ã—ã¦ã¿ã‚ˆã†  

## ãƒ¡ãƒ³ãƒå¤‰æ•°

- `Vec center` : çƒã®ä¸­å¿ƒåº§æ¨™  
- `float radius` : çƒã®åŠå¾„  

## ãƒ¡ãƒ³ãƒãƒ¡ã‚½ãƒƒãƒ‰

- `isIntersect`

# çƒã¨åŠç›´ç·šã®äº¤å·®åˆ¤å®š

ãƒ¬ã‚¤ã¨çƒã®ä½ç½®é–¢ä¿‚ã‹ã‚‰é€£ç«‹æ–¹ç¨‹å¼ã‚’ç«‹ã¦ã¦è§£ã‚’èª¿ã¹ã‚‹  
å††ã¨åŠç›´ç·šã®äº¤å·®åˆ¤å®šã®ï¼“æ¬¡å…ƒç‰ˆ  

**æˆ‘ã€…ãŒå¼ã‚’æ±‚ã‚ã‚‹å¿…è¦ã¯ãªã„ï¼**  
æˆ‘ã€…ãŒçŸ¥ã£ã¦ã„ã‚‹ã¹ãã“ã¨ã¯ã€Œä½¿ãˆã‚‹å¼ãŒã‚ã‚‹ã€ã¨ã„ã†ã“ã¨  
å¼è‡ªä½“ã¯ã‚°ã‚°ã‚Œã°ã™ãå‡ºã‚‹

# isIntersect (Sphere)

```Processing
class Sphere implements Intersectable {
  boolean isIntersect(Ray ray) {
    Vec v = ray.origin.sub(center);
    float b = ray.dir.dot(v);
    float c = v.dot(v) - sq(radius);
    float d = b * b - c;
    if (d >= 0) {
      float s = sqrt(d);
      float t = -b - s;
      if (t <= 0)  t = -b + s;

      if (0 < t) {
        return true;
      }
    }
    return false;
  }
}
```

# Scene

**ç©ºé–“** ã¯ `Scene` ã¨ã—ã¦å®šç¾©ã—ã¾ã™  

```Processing
class Scene {
  ...
}
```

# ObjList

ã¾ãšã€ç©ºé–“ã¯ãƒ¢ãƒã®é›†åˆã‚’æŒã¤å¿…è¦ãŒã‚ã‚‹  

```Processing
class Scene {
  ArrayList<Intersectable> objList = new ArrayList<Intersectable>();

  void add(Intersectable obj) {
    objList.add(obj);
  }
}
```

# isIntersect (Scene)

ç©ºé–“å†…ã®ä»»æ„ã®ãƒ¢ãƒã¨äº¤å·®ã™ã‚Œã° `true` ã‚’è¿”ã™  

```
class Scene {
  boolean isIntersect(Ray ray) {
    for (int i = 0; i < objList.size(); i ++) {
      Intersectable obj = (Intersectable) objList.get(i);
      if (obj.isIntersect(ray)) {
        return true;
      }
    }
    return false;
  }
}
```

# ã¨ã‚Šã‚ãˆãšãƒ¬ã‚¤ã‚’é£›ã°ã—ã¦ã¿ã‚‹

```
scene = new Scene();

Vec sphereCenter = new Vec(0.0, 0.0, 0.0);
float sphereR = 1.0;
Sphere sphere = new Sphere(sphereCenter, sphereR);
scene.add(sphere);

Vec rayOrigin = new Vec(0.0, 0.0, 5.0);
Vec rayDir = new Vec(0.0, 0.0, -1.0).normalize();
Ray ray = new Ray(rayOrigin, rayDir);

println(scene.isIntersect(ray));
```

`true` ãŒè¿”ã£ã¦ãã‚Œã°OKï¼  
`rayDir` ã‚„ `rayOrigin` ãªã©ã‚’ã„ã˜ã£ã¦éŠã‚“ã§ã¿ã‚ˆã†  

# æç”»ã—ãŸã„â€¦â€¦

ãƒ¬ã‚¤ã¯é£›ã°ã›ãŸãŒã€æç”»ã¯ã§ãã¦ã„ãªã„â€¦  

Remember: æœ€çµ‚çš„ã«æˆ‘ã€…ã¯ã€ çµµã‚’æ§‹æˆã™ã‚‹å„ãƒ”ã‚¯ã‚»ãƒ«ã«å¯¾å¿œã™ã‚‹è‰²ã‚’çŸ¥ã‚ŠãŸã„  
â†’ **å„ãƒ”ã‚¯ã‚»ãƒ«ã«å¯¾å¿œã™ã‚‹ãƒ™ã‚¯ãƒˆãƒ«ã‚’çŸ¥ã‚ŠãŸã„**  
â†’ ã‚«ãƒ¡ãƒ©ã‚’ä½œã‚ã†  

# Camera

`Camera` ï¼ˆã‚«ãƒ¡ãƒ©ï¼‰ã‚¯ãƒ©ã‚¹ã‚’ç”¨æ„ã—ã¦ã‚ã‚Šã¾ã™  

## ä½¿ã„æ–¹

- `void camera.lookat(...)` ã¨ã„ã†é–¢æ•°ã§åˆæœŸè¨­å®šã‚’ã™ã‚‹  
- `void camera.fov(fov)` ã¨ã„ã†é–¢æ•°ã§è¦–é‡è§’ã‚’è¨­å®šã§ãã‚‹  
- `Ray camera.ray(x, y)` ã§ãƒ”ã‚¯ã‚»ãƒ«ã®åº§æ¨™ã«å¯¾å¿œã—ãŸãƒ™ã‚¯ãƒˆãƒ«ãŒå–ã‚Šå‡ºã›ã‚‹  

## lookat

```
camera.lookat(
  eye, // ã‚«ãƒ¡ãƒ©ã®ä½ç½®
  target, // ã‚«ãƒ¡ãƒ©ã®æ¨™çš„
  up, // ã»ã¨ã‚“ã©ã®å ´åˆã€ Vec(0.0, 1.0, 0.0) ã§OK
)
```

# æç”»ï¼

```
void setup() {
  scene = initScene();

  Vec sphereCenter = new Vec(0.0, 0.0, 0.0);
  float sphereR = 1.0;
  Sphere sphere = new Sphere(sphereCenter, sphereR);
  scene.add(sphere);

  camera = new Camera();
}
```

```
Scene initScene() {
  Scene scene = new Scene();

  Vec sphereCenter = new Vec(0.0, 0.0, 0.0);
  float sphereR = 1.0;
  Sphere sphere = new Sphere(sphereCenter, sphereR);
  scene.add(sphere);

  return scene;
}
```

```
color calcPixelColor(int x, int y) {
  Ray ray = camera.ray(x, y);

  if (scene.isIntersect(ray)) {
    return color(255);
  } else {
    return color(0);
  }
}
```

# å®Œæˆï¼

![](https://i.imgur.com/OGeGweq.png)

# ãƒ¢ãƒã¯ãŸãã•ã‚“å‡ºã›ã¾ã™

```
Scene initScene() {
  ...

  for (int i = 0; i < 5; i ++) {
    Vec sphereCenter = new Vec(i - 2, 0.0, 0.0);
    float sphereR = 0.5;
    Sphere sphere = new Sphere(sphereCenter, sphereR);
    scene.add(sphere);
  }

  ...
}
```
